# 6주차. 이분 탐색
## 2805. 나무 자르기 (실버 3)
### 구현
일반적인 이분 탐색을 풀었다.

이분 탐색의 기준은 자르는 높이로 잡고, 가장 작은 값보다는 커야 하고 가장 큰 값보다는 작아야 하므로 이 사이의 값을 가지고 이분 탐색을 진행했다.


### 틀렸습니다.
적어도 M미터의 나무라는 말을 못보고 정확히 M? 을 가져가야 한다고 생각했다.

그래서 조건을 입력할때 아래처럼 했는데 이럼 틀렸습니다가 나온다. 

== 대신에 >=을 해야지 적어도 M미터의 지문이 충족된다.
```cpp
if(cutting == m){
    answer = answer > mid ? answer : mid;
}    
```

### 사족
이때까지 반대로 정렬할때, 우선 정렬하고 reverse함수를 사용했는데 그냥 바로 sort(arr.rbegin(), arr.rend())를 사용하면 됐었다! 이걸 몰랐네


## 3020. 개똥벌레 (골드 5)
### 구현 1
우선 석순과 종유석에 대해서 따로 배열을 만들고 해당 인덱스++을 해줬다. (1,5,3,3,5,1)이면 석순배열에는 각각 1,3, 5인덱스에 0이 아니라 1이 있다. 종유석도 동일

그리고나서 마지막 인덱스부터 보면서 현재 인덱스에 바로 다음 인덱스의 값을 더해준다.
```cpp
for(int i=h; i>=1; i--){
    suk[i] += suk[i+1];
    jong[i] += jong[i+1];
}
```
그러면 석순과 종유석 둘 다 [3, 2, 2, 1, 1, 0, 0] 이렇게 들어간다.

종유석은 반대로 봐야 하니깐 sum을 더할 때, 
```cpp
for(int i=1; i<=h; i++){
    sum.push_back(suk[i]+jong[h-i+1]);
}
```
그리고 나서 sum을 정렬하고 가장 작은 수가 몇개 들어 있는지를 판단한다.


### 구현 2 (이분탐색 사용)

```cpp
int main(){
    int Min = 0x7fffffff;
    int cnt = 0;
    scanf("%d %d", &n, &h);
    for(int i=0; i<n/2; i++){
        int s, j;
        cin >> s >> j;
        suk.push_back(s);
        jong.push_back(j);
    }
    sort(suk.begin(), suk.end());
    sort(jong.begin(), jong.end());
    
    for(int i=1; i<=h; i++){
        int idx = lower_bound(suk.begin(), suk.end(), i) - suk.begin();
        idx += lower_bound(jong.begin(), jong.end(), h-i+1) - jong.begin();
        idx = n - idx;
        
        if(idx < Min){
            Min = idx;
            cnt = 1;
        }
        if(idx == Min){
            cnt++;
        }
    }
    printf("%d %d\n", Min, cnt-1);
    return 0;
}
```
-> 높이를 정렬했기 때문에 한 곳에서 걸리면 그 뒤에는 다 걸린다고 생각하면 된다.
그래서 lower_bound로 해당 높이가 있는 인덱스를 찾는다. 이 인덱스는 i번째 높이에서 걸렸어! 라는 의미다. 그래서 인덱스 0에서 걸렸다면 무조건 이 뒤의 인덱스에서 다 걸린다는 얘기니까 n-i를 해주면 걸린 석순 or 종유석의 개수가 나온다.


### 사족
```cpp
 int cnt = 1;
    int Min = sum[0];
    for(int i=1; i<h; i++){
        if(Min == sum[i]){
            cnt++;
        }
}
```
처음에는 위와 같은 방식으로 갯수를 세긴했는데 다른 사람들의 코드를 보니 

upper_bound, lower_bound를 사용했더라. 그래서 공부했다.

이분 탐색기반으로 탐색을 하며, 배열은 무조건 정렬되어 있어 야 한다.


* **lower_bound** : 타겟 넘버와 같거나 큰 숫자(큰 숫자 중 가장 작은 숫자)의 인덱스 
* **upper_bound** : 타겟 넘버보다 큰 숫자의 인덱스 (같은 값이 아님!)
각각 세번째 인덱스에 타겟넘버를 입력한다.


## 1365. 꼬인 전깃줄 (골드 2)
LIS문제! 가장 긴 증가하는 수열을 구하고 전체 전봇대수 - 수열갯수를 하면 제거해야 할 전선의 수가 나온다.

lis라는 이름의 벡터를 만들고 만약 현재 숫자가 lis마지막 숫자보다 크면 lis 벡터에 그냥 넣고 작으면 해당 arr[i]숫자가 들어갈 위치를 찾는다.

이걸 lower_bound를 사용해서 찾았는데, logn이 걸리기 때문에 빠르게 찾을 수 있다.

```cpp
for(int i=0; i<n; i++){
    if(lis.empty()){
        lis.push_back(arr[i]);
        continue;
    }
    int last = lis.back();
    if(last < arr[i]){
        lis.push_back(arr[i]);
        continue;
    }
    int index = lower_bound(lis.begin(), lis.end(), arr[i]) - lis.begin();
    lis[index] = arr[i];
}
```


## 12738. 가장 긴 증가하는 부분 수열 3 (골드 2)
위의 코드에서 범위만 바꾸면 됨.. 바로 풀었땅


## 9007. 카누 선수 (골드 4)
n의 제한이 1000이어서 O(n^3)으로는 못푼다. 그래서 O(n^2)내에서 풀어야 한다.

우선 (0, 1), (2, 3) 각각에 대한 합은 구해준다. (n^2으로 가능)

그리고 나서 각각의 합을 오름차순으로 정렬한다.

k - sumArr[0][i] 값 (tmp) 보다 같거나 큰 값의 인덱스를 sumArr[1]에서 lower_bound로 찾는다. (tmpIndex)

그리고 나서 tmp 값보다 큰 숫자와 작은 숫자의 차이가 같다면 작은 숫자를 선택해야 하므로 

tmpIndex > 0인 경우에 (-1을 해도 인덱스에서 안벗어나는 경우) tmp-sumArr[1][tmpIndex-1]의 차이와, tmp-sumArr[1][tmpIndex]의 차이를 같이 본다. 그렇지 않으면 후자만 본다.

그리고 나서 중요한게, 차이가 같은 경우에 더 작은 숫자를 선택해야 한다. (이걸 생각 못해서 오래걸림..)


### 틀렸습니다
차이가 같거나 작은것들 중에서 숫자도 비교를 했었어야 했는데 이걸 생각 못해서 13번째 제출만에 맞췄당….

아 그리고 인덱스에 -1 을 할때는 0보다 큰지를 봐야하는데 이것도 안봄…. 토할거 같당.. 


## 11967. 불켜기 (골드 3)
현재 위치에서 켤 수 있는 불을 켠다. 여기서 불을 켰다면 flag를 true로 바꿔주는데, check배열이랑 q를 비우라고 알려주는 역할을 한다.

그리고 나서 사방을 보고 check가 되어있거나, 빛이 들어오지 않은 상태면 그냥 넘어가고 그렇지 않으면 체크해주고 queue에 넣어준다.

그렇게 해서 불을 켠 수를 출력해준다.

### 사족
아기상어 문제와 비슷하다. 근데 아기상어때 고민했던 부분을 여기서 또 오랜 시간 고민했다… 그래서 살짝 자괴감을 느꼈지만 금방 좋아졌다..! 비슷한 유형의 문제를 많이 풀어봐야겠다고 생각했다.

## 1114. 통나무 자르기 (골드 1)






















