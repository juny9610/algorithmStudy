# 3주차. 다익스트라, 벨만-포드, 플로이드 와샬
## 1753. 최단 경로 (골드 5)
기본 다익스트라 개념으로 품
**시간 초과** - 일단 시작이 무조건 1이 아니라는것을 생각하지 못함… 문제를 제대로 읽자 제발..
근데 그래도 시간초과 남….
왜났냐면……cin, cout 때문에에……………………………………………………

## 11657. 타임머신 (골드4)
**틀렸습니다** - 
```cpp
if (distance[node] == MAX)
    continue;
```
구문이 없어서 틀렸습니다가 뜸…

distance배열에서 현재노드가 MAX값을 가지고 있으면, 
더할때 그냥 MAX가 돼서 배열 업데이트가 안된다.

예를 들어 첫번째 예제에서, 1을 0이 아니라 그냥 MAX로 설정하면, distance[2] 에서 값을 업데이트 할때, 4+MAX < MAX 이런식으로 비교가 되기 때문에 생각했던 대로 업데이트가 잘 되지 않는다.

**출력 초과** - distance의 타입을 int가 아니라 long long int로 했어야 함.

**틀렸습니다** - 원래 코드는 n-1번 확인 후에, 한번 더 포문을 돌아서 값 업데이트가 이루어지는지 체크했다.

근데 계속 틀렸습니다가 나서

그냥 n번 돌리고, 만약에 n번째에서 업데이트가 일어난다면 flag를 false(음의 사이클이 있다는 말)로 바꾸어 주었다.

왜 바로 위에서 틀렸습니다가 날까 생각을 해봤는데 n번째에 대해서 추가로 for문을 빼서 체크를 할때 distance[node] == MAX 인 경우에 대해서 체크를 안해줬넹..헤 

그래서 틀렸습니다가 남! 조건을 추가하고 다시 제출을 했더니 맞았습니다 가 떴음..!


## 11404. 플로이드 (골드 4)
플로이드 이론으로 품.
근데 처음에 MAX값을 int의 최대 값인 0x7fffffff로 설정했는데, 계속 배열에 값이 이상하게 들어감.

그리고 나서 그냥 문제에 있는 최대 값으로 바꿨는데 값이 잘 들어감..

이유가 뭐지? 오버플로우…..0x7fffffff 이 너무 크다..! 21억임

**틀렸습니다** - MAX값 문제…..

이것도 최악의 경우를 생각해보자.

위에 처럼 a에서 b까지 가는 길이 일렬로 있다고 해보자.

엣지가 최대 99개니까 최대로 나올 수 있는 비용은 (99*100000) 이다.
그래서 MAX값을 천만으로 잡아야 한다.

시간복잡도랑 최대값 구하는게 헷갈리넹..……..휴………………..


## 1238. 파티 (골드 3)
기존의 다익스트라와는 달리, distance배열을 이중배열로 정했다.

행 번호 의미는 스타트 번호, 열의 의미는 원래 distance의 의미로 설정했다.

(1행은 시작노드가 1, 2행은 시작 노드가 2…. 이런식으로)

그리고 나서, for(int i=1; i<n+1; i++) 로 각 시작점에 대한 다익스트라를 돌리고, distance배열을 채워주었다.

Distance 배열을 다 채우고 나서 위의 for문이 끝난 후에는 i 에서 x 로 갔을 때의 최단 경로와 x에서 i로 갔을 경우의 최단 경로를 더한 값들의 Max를 구해서 출력했다.

한번에 맞춰서 기분좋은 문제!


## 1865. 웜홀 (골드 4)
처음에 계속 9프로에서 틀렸습니다가 나와서 질문 검색으로 보니 
```c++
if(distance[node] == MAX){
    continue;
}
```
부분 때문에 계속 틀렸습니다가 나왔다고 한다.

저 부분을 빼줘야 한다. 우리가 알고 싶은 것은 cycle의 유무이지 실제 최단 거리 계산이 아니다. 

그래서 저 부분을 빼주고, 마지막에 한번 더 for문을 돌려서 값의 변화가 있는지만 확인하면 된다. (그래서 굳이 무한대로 초기화 안해줘도 됨.)

저 부분을 포함했을 시 반례 ).
```c++
1
3 2 0
2 3 -1
3 2 -1
```
위에 부분은 1과 2,3이 연결되어있지 않아서 위의 부분을 포함시킨다면 2와 3을 체크하지 않고 그냥 넘어갈 것이기 때문에 틀렸습니다가 나온다.

## 2458. 키 순서 (골드 4)
기본 플로이드 와샬 문제
먼저 노드를 나타내는 이중 배열을 하나 만들고(전체를 MAX로 설정), 입력으로 들어온 방향을 해당 배열에 1로 설정한다.

그리고 나서, 만약에 중간 지점을 통해서 연결이 되어 있으면(위에서 1로 체크를 해줬기 때문에) 당연히 arr[i][k] + arr[k][j] 값이 MAX값보다 작으므로, 배열에 arr[i][k] + arr[k][j] 값을 넣어 주었다.

알고리즘이 끝난 후에는, 위에서 체크한 값은 나보다 큰 값의 경우에만 값을 넣어주었으므로,
나보다 작은 값의 경우도 같이 체크해주기 위해서 

조건문으로 arr[i][j] != MAX || arr[j][i] != MAX 로 설정했다.

이 문제도 위에 웜홀 문제처럼 최단 거리를 구하는게 중요한게 아니라 연결이 되어있는지 안되어있는지를 체크만 하면 되기 때문에 사실 배열에 arr[i][k] + arr[k][j]  값이 아니라 MAX가 아닌 다른 값을 넣어줘도 괜찮다.

## 4485. 녹색 옷 입은 애가 젤다지? (골드 4)
다익스트라 아이디어를 이용해서 풀었다.

우선, 최소 루피를 저장할 이중배열(rupee)을 하나 만들고 MAX값으로 채워준다.

물론 1,1 에서 시작할거기 때문에 1,1 에는 arr[1][1] 값을 넣어준다.

priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;를 만들어주는데,  여기서, 가장 앞의 int값은 루피를 의미하고, 바로 뒤의 페어는 각각 x, y를 의미한다.

최소 루피를 사용해야 하므로, greater로 설정하여 오름차순으로 정렬되도록 한다. (Min heap)

pq가 빌때까지 while문을 돌면서, 사방을 확인한다.

만약 rupee[nx][ny]의 값이 r + arr[nx][ny]의 값보다 크다면, 

ruppee[nx][ny]의 값을 r + arr[nx][ny]로 갱신해준다. 그리고 pq에 넣어준다.

while문이 끝나고 나면 rupee[n][n]에는 가장 최소의 루피가 저장되어 있을 것이다!


## 2610. 회의준비 (골드 2)
전반적인 순서는, 우선 dfs로 연결되어있는 위원회 수를 찾는다.

그리고 플로이드 와샬로 연결되어있는 노드로 갈 수 있는 값을 구하고 배열에 저장한다.

해당 노드에서 갈수있는 노드들에 대한 최대값을 구하고, 이 최대값들에 대한 최소값을 가진 노드의 수를 set에 저장한다. (set을 사용한 이유는 자동으로 오름차순으로 정렬해줌)

그리고 연결되어있는 부분을 배열에 체크해줄때, 노드가 하나만 있는 경우도 있기 때문에 자기 자신에 대한 곳도 체크를 해줘야한다. 

**틀렸습니다** - 처음에 틀렸습니다가 나온 이유는 각 노드에서 연결된 노드로 가는 길에 대한 합을 더해서 그 합 중에 가장 작은 값을 가진 노드를 출력했는데 이렇게 되면, 최대값에 대한 최소값이라는 문제 지문을 충족하지 않는다. (합의 최대가 아니라 그냥 특정 노드로 가는 최대값이여서)
```c++
// 틀렸습니다에 대한 반례
7
6
1 2
2 3
3 4
4 5
4 6
4 7
```

**결론** - 제발 문제 좀 잘 읽자..!


## 1219. 오민식의 고민 (골드 2)
처음에는 그냥 벨만 코드 이후에 사이클이 있는지 없는지 판단해서 사이클이 있으면 Gee를 출력하고 끝낼려고 했음..
근데 사이클이 있을 때, 목적지에 도착할 수도 있고 없을 수도 있다는 생각이 들긴 드는데 사이클에 해당하는 노드 찾는게 잘 생각이 안나서 못짬
아 어렵네….
##  10217. KCM Travel (골드 1)
이건 더 어렵네.....













