# 4주차. 구현
## 12100. 2048 (Easy) (골드 2)
백트래킹으로 풀었당.

우선 최대 5번 움직일 수 있으니까, 위, 아래, 왼쪽, 오른쪽의 순열(int direction[5])을 dfs로 생성한다. 

(그럼 가장 처음은 위위위위위, 위위위위아래, 위위위위왼, 위위위위오,…. 이런식으로 direction배열이 채워진다.)

만약 5 개의 순서로 direction 배열이 채워지면 (if(cnt == 5)) 지금 현재 상태의 arr를 tmp배열에 채워 넣고 (dfs 가 끝났을 때 다시 arr배열을 원상복구 시켜야 하므로) 해당 방향에 대한 함수를 실행한다. -> game()

### game()
game함수 내부에서는 앞에서 채웠던 direction 배열에 있는 방향 순서대로 arr를 옮긴다.

다 옮기고 나서는 바뀐 arr에서 가장 큰 숫자를 Max값과 비교해서 더 큰 숫자를 저장한다.

### up, down, left, right
Left, right 함수에서는 가로로 한줄씩 움직이므로 위에서 부터 가로로 한줄씩 보고

Up, down 함수에서는 세로로 한줄씩 움직이므로 가장 왼쪽에서부터 세로로 한줄씩 본다.

아래는 left함수의 예시이다.
```cpp
void left(){
      for(int i=0; i<n; i++){
          for(int j=0; j<n; j++){
              if(arr[i][j] != 0){
                  q.push(arr[i][j]);
                  arr[i][j] = 0;
              }
          }
          int index=0;
          while(!q.empty()){
              int num = q.front();
              q.pop();
              if(arr[i][index] == 0){
                  arr[i][index] = num;
              }
              else if(arr[i][index] == num){
                  arr[i][index] *= 2;
                  index++;
              }    
              else{
                arr[i][++index] = num;
              }
        }
    }
}
```
우선 현재 가로줄에 0이 아닌 숫자가 있으면 차례로 queue에 넣어준다.

![0](https://github.com/kanghuiseon/algorithmStudy/blob/heeseon/Rare4_구현/hee/Resource/0.png)

그림에서처럼 순서대로 넣어준다!

만약 현재 위치의 값이 0이면 그냥 넣어주고, num이랑 같으면 현재 위치의 값을 2배로 해준다.

다른 숫자가 들어가있으면 그 다음 자리에 num값을 넣어주면 된다.

위에는 left 코드만 있는데 right, up, down 모두 같은 방식으로 해준다. (걍 복붙해서 i, j 쪽만 바꿔주고, index ++할지 - - 할지만 결정하면 됨.)



## 15686. 치킨 배달 (골드 5)
### 구현
입력을 받을 때 치킨인 부분을 따로 vector에 넣어줌.

그리고 dists배열도 하나 만들어줬는데, 이게 의미하는게 뭐냐면 현재 arr[i][j]의 값이 1일때 (집) 치킨 집의 위치와 현재 집의 거리를 구해서 dists[i][j]에 넣어줬다. 

물론 치킨집 위치에서 현재 집까지 최소로 걸리는 값이 들어가야 하기 때문에 넣어줄때 min함수로 비교해서 더 작은 값을 넣었다.

그리고 현재까지 본 치킨집의 수가 m개가 되었을때, 이 dists배열의 모든 값을 더해서 Min값에 넣었다.

그래서 dfs를 진행할 때, 

현재 dists 배열을 tmp배열에 따로 저장을 해준다. (다시 돌아왔을 때 를 위해서)


### 시간 초과
```cpp
for(int c=current; c<chicken.size(); c++){
    for(int i=1; i<n+1; i++){
        for(int j=1; j<n+1; j++){
            if(arr[i][j] == 1){
                int dist = abs(chicken[c].first - i) + abs(chicken[c].second - j);
                dists[i][j] = min(dists[i][j], dist);
            }
        }
    }
    dfs(cnt+1, c+1, dists);
    for(int i=1; i<n+1; i++){
        for(int j=1; j<n+1; j++){
            dists[i][j] = tmp[i][j];
        }
    }
}
```
위에서 dfs로 다시 들어갈때 현재 인덱스 값 +1 로 들어가야 했는데 현재 파라미터로 들어온 current값 + 1로 dfs를 들어가서 시간초과가 났다.

current값으로 하면 for문은 이미 chicken.size()-1까지 돌았는데 dfs는 current부터 다시 들어가는거니까 시간초과가 날 수 밖에 없지…..바보냐….




## 13460. 구슬 탈출 2 (골드 2)
bfs인지 모르고 생각이 너무 안나서 슬쩍 알고리즘 분류 봤당… 이건 반성해야지 후

일단 입력을 받을때 빨간 구슬, 파란 구슬이 있는 곳을 보고 check를 해주고 queue에 넣어준다.

그리고 나서, dx, dy를 만들어서 왼쪽, 오른쪽, 위, 아래 순서대로 구슬을 벽을 만나거나 ‘O’을 만날때까지 굴린다. roll은 굴리는 함수이다.

cnt가 왜 필요하냐면, R, B를 저렇게 굴려서 겹치는 경우가 있어서, 더 많이 구른? (cnt가 더 큰) 구슬을 한칸 전으로 돌려주도록 하기 위해서 필요하다.
```cpp
tuple<int, int, int> roll(int x, int y, int di, int cnt){
    while(arr[x+dx[di]][y+dy[di]] != '#' && arr[x][y] != 'O'){
        x += dx[di];
        y += dy[di];
        cnt += 1;
    }
    return make_tuple(x, y, cnt);
}
```

그리고 나서 새로운 nrx, nry, nrcnt, nbx, nby, nbcnt를 보고, 만약 

새로운 R의 값이 ‘O’이고 B의 새로운 값이 ‘O’가 아니면 현재까지 굴린 수를 출력한다.

만약 새로운 B의 값이 ‘O’이면 그냥 continue; 한다.

그리고 만약 위치가 같다면 각각의 cnt값을 비교해서 cnt값이 더 큰 구슬을 한칸 빽 한다.

그리고 새로운 위치가 이미 방문한 곳이면 continue하고, 아니면 체크해주고 큐에 넣어준다. 

이 과정을 큐가 빌 때까지 반복하고, 만약 뷰가 빌때까지 반복해도 return;이 안됐다면 -1을 출력하고 끝낸다.




이 문제는 옛날에 풀어본 유형이랑 비슷해서 그나마 좀 다른 문제보다는 수월? 하게 …풀었나..? 어쨌든 패쓰





## 3190.  뱀 (골드 5)
### 구현
head와 tail을 따로 보고 코드를 진행했다. (head의 위치, 방향(hf), tail의 위치와 방향(tf) 모두 따로 관리함)
```cpp
int nx = head.first + dx[hf];
int ny = head.second + dy[hf];
```
nx,ny(다음에 이동할 위치)가 범위를 벗어나거나 자기 몸이면 그냥 시간을 출력하고 while문을 빠져나온다.

만약 사과라면 head의 위치만 옮겨주고 배열에 뱀이라는 표시로 arr[nx][ny] = 2 로 해준다.

(0이면 빈, 1이면 사과, 2면 뱀 몸)

그리고 만약 빈 곳이면, arr에서 tail이었던 부분을 0으로 하고 새로운 nx,ny부분을 2로 바꾼다.

그리고 tail의 위치도 꼬리의 방향에 맞게 바꿔준다.

head의 위치는 nx, ny로 바꿔준다.


그리고나서는 시간을 업데이트 해주고,

만약 현재 시간(t)와 방향의 정보가 들어있는 dir[dirIndex].first가 같다면, dir[dirIndex].second에 따라 head의 방향을 바꿔준다.

그리고 중요한게 tail은 항상 head의 방향과 같지 않기 때문에 방향을 바꾸는 위치의 정보와 명령어를 tailDirection queue에 넣어준다.
(만약 tail이 해당 위치에 도착했다면, tail의 방향을 바꿔준다.)

### 사족
처음에는  머리와 꼬리의 방향을 같은 변수 f로 다뤘다.

근데 뱀이 방향을 꺾을 때 머리와 꼬리의 방향이 다를 수도 있다는 것을 깨닫고 따로 관리했다.s

27일전에 못풀었는데 27일 후인 오늘은 풀었다. 그것도 꽤 빨리! 두시간!! 긴건가? 어쨌든! 정신승리!





## 17143. 낚시왕 (골드 2)
### 구현
### 땅에서 가까운 상어 제거
우선 상어의 크기가 같은 경우는 없다고 해서 상어의 크기를 Key값으로 가지는 map을 하나 만들어 줬다. (Sharks)

그리고 나서 arr배열에는 상어의 크기만 저장했다.

왜 map을 사용해서 했냐면 상어를 제거할 때 상어 크기(key)값으로 바로 상어 무리에서 제거할 수 있기 때문이다. (map은 레드블랙트리로 구현되어있어서 삽입, 삭제가 logN이라 빠름)

```cpp
for(int i=1; i<r+1; i++){
    // 땅에서 가장 가까운 상어 지우기
    if(arr[i][person] != 0){
        sum += arr[i][person];
        sharks.erase(arr[i][person]);
        arr[i][person] = 0;
        break;
    }
}
```


### 상어 움직이기
Sharks map에 있는 상어를 가지고 현재 방향에 맞게 움직여준다. 

그리고 sharks에서 바로 상어를 제거하면 for문 돌릴때 이상하게 되는 경우가 있으므로 ttmp라는 vector에 일단 상어의 새로운 위치값을 넣어주고 모든 상어를 다 옮기고 나서 ttmp의 값들을 shark map 에 새롭게 업데이트 해준다.

물론 이전의 상어 위치에 대해서는 arr[pr][pc] = 0을 해줘야 한다.



### 같은 칸의 상어들 처리
같은 칸에 상어가 두 마리 이상 있으면 가장 큰 크기의 상어가 모두 잡아먹는다고 했다.

그래서 제거할 상어들을 넣을 tmp 배열을 하나 생성하고, 

sharks의 상어들을 하나씩 보면서 만약 arr[dr][dc]의 값이 0이 아니면 (이미 다른 크기의 상어가 있다면) 크기 비교를 해서 작은 상어를 tmp에 넣어준다.

모든 상어를 봤으면 마지막에 tmp의 상어들을 sharks map에서 삭제해준다.!!

위의 과정을 while(c- -) 동안 (낚시왕이 오른쪽 끝까지 갈때동안) 해준다!



### 시간 초과
while(tmpC)
    for(sharks)
        while(tmpS)
100 X 10000 X 1000 = 십억! 당연히 시간초과 나지…

어떻게 해결했냐면 처음에는 상어를 한번한번씩 옮겨줬다 그래서 세번째 while문이 최대 1000번 돌아갔는데,
이걸 제일 처음에 s를 받을때 만약 위,아래 방향이면 s %= (r-1)*2, 왼쪽, 오른쪽 방향이면 s%= (c-1)*2 로 계산해서 최소한의 움직임만 할 수 있도록 했다. (한바퀴 돌아서 자기자신의 위치로 돌아오는 경우를 제거해줌)


## 17144. 미세먼지 안녕! (골드 5)
안녕하지 못함….

노가다………. 노가다……….

### 구현
일단 가장 처음에 입력 받을 때 공기 청정기의 위치를 pair에 따로 담아준다. (pair<int, int> Up, down)

그리고 나서 t번 돌아야 하니까 while문으로 해주고, dx, dy만들어서 양 사방 다 본다.

미세먼지를 확산한 만큼 값을 현재 위치의 값을 업데이트 해줘야 하므로, 우선 cnt의 개수를 먼저 체크하고, 현재 위치의 값을 업데이트 해줬다.

순한을 할때는 위에 부분, 아래 부분 함수를 따로 만들어서 구현했다. (upMise, downMise)

### upMise, downMise
각 함수는 공기 청정기의 위치를 파라미터로 받고 해당 위치를 기준으로 위쪽이면 반시계 방향, 아래쪽이면 시계 방향으로 tmp배열을 업데이트 해줬다.

위쪽의 경우만 한번 보자.

처음의 방향값을 오른쪽으로 잡고 공기청정기의 위치를 기준으로 가장 오른쪽, 맨 오른쪽 위, 공기청정기 위치에서 가장 위쪽, 공기청정기 위치순으로 방향을 바꿔준다.

그리고 tmp[nx][ny] (다음 위치) 값에는 arr[curX][curY] (현재 위치)값으로 업데이트해주고 curX = nx; curY = ny; 이렇게 현재 위치도 업데이트 해준다.
(아래쪽도 똑같은 방식으로 품, 방향 업데이트만 다름)

### 틀렸습니다.
이건 진짜 계속 똑같은 이유로 틀렸습니다가 나오는데
강희선 제발 좀 정신 차렸으면 좋겠다.

디버깅할려고 MAX_INDEX값 작게 해놓은거 자꾸 안고치는데 제발 정신 좀 차려!!!!



## 19237. 어른 상어 (골드 3)
### 구현
처음에는 상어에 대한 정보를 tuple로 다뤘었는데 
tuple의 인덱스에 접근할때 get<> 꺽쇠 안에 무조건 숫자만 들어갈 수 있다는걸 이번에 처음 알았다……….전혀 몰랐음 변수로 안들어감

그래서 어떻게 하지….하다가 다른 사람들은 어떻게 했나 봤는데 struct로 관리하길래
나도 struct를 한번 써보기로 했다!
```cpp
typedef struct shark{
    int dir;
    bool isAlive;
    int x;
    int y;
    int priority[5][4];
}Shark;
```
과정은 순서대로, 
1. 만약 상어가 살아있다면 움직일 위치를 찾고, 움직일 위치에 이미 어떤 상어가 있다면 값을 비교한다. 나보다 크면 죽이고 내가 거기서 산다. 나보다 작으면 내가 죽는다.
2. 만약 아무 상어가 없다면 내가 거기서 산다.
3. 이동할 곳이 없는 경우에는 자기 자신의 냄새가 있는곳을 다시 찾아서 돌아간다.
4. 모든 상어를 다 옮겼으면 현재 위치에 새로 냄새를 남기도록 한다.
5. arr[i][j] (상어의 위치)의 값은 0 이지만 냄새가 남아 있는 경우에는 냄새를 1씩 줄이고 만약 1 줄였는데 0이 됐다면 상어에 대한 정보도 지운다.
6. 이렇게 1이 남을 때까지 반복하고 만약 끝까지 다른 상어가 남아있다면 -1을 출력하도록 한다.

### 사족
그냥 완전 쌩노가다 구현문제. 지켜야할 조건이 많아서 좀 헷갈렸다. 구조체를 처음 써봤는데 tuple보다 덜 헷갈리는거 같아서 종종 애용해야겠다!







## 15684. 사다리 조작 (골드 4)
처음에 생각하는게 좀 어려웠던게 줄로 생각을 해서 좀 헷갈렸다.



### 구현
그래서 1번 줄과 2번 줄사이에 가로줄이 있다면 배열의 1번 위치에다가 체크를 해줬다.

가로줄을 추가해줬다 빼줬다 해야 해서 백트래킹을 생각했고, 

만약 현재 추가한 횟수가 3을 넘기면 return하고, 정답인 상태여도 return 했다.

dfs들어가는 조건은 만약 사다리가 겹치는 부분이 있으면 사다리 추가를 안해주고 겹치지 않는다면 dfs를 들어갔다.

현재 사다리가 정답인지를 체크할 때는
```cpp
bool check(){
    for(int i=1; i<n+1; i++){
        int ans=i;
        for(int j=1; j<h+1; j++){
            if(arr[j][ans] == 1){
                ans++;
            }
            else if(arr[j][ans-1]){
                ans--;
            }
        }
        if(ans != i)
            return false;
    }
    return true;
}
```
각 세로줄마다 진행했고 만약 오른쪽 위치에 가로줄이 존재하면 오른쪽으로 움직였고(ans++), 왼쪽 위치에 가로줄이 존재하면 왼쪽으로 이동(ans- -)한다.

그리고 다 움직인 후에 현재 위치한 줄 ans의 값이 i의 값과 다르면 false를 리턴하였고, 같으면 다음 줄을 확인하도록 했다.































